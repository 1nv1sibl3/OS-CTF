# Analysis

A typical form of RSA encryption, but there is a point that we should note that q =
nextprime(p), that is, p and q are two adjacent primes, and p * q = n => p and q are very
close to the square root of n.

# decoder

```
from decimal import *
from Crypto.Util.number import *

getcontext().prec = 1024
def findPandQ(n):
    r = int((Decimal(n).sqrt()))
    for p in range (r, 1, -2):
        if (n % p == 0):
            q = n // p
            return (p, q)


n = 20159884168863899177128175715030429666461733285660170664255048579116265087763268748333820860913271674586980839088092697230336179818435879126554509868570255414201418619851045615744211750178240471758695923469393333600480843090831767416937814471973060610730578620506577745372347777922355677932755542699210313287595362584505135967456855068550375989801913361017083952090117041405458626488736811460716474071561590513778196334141517893224697977911862004615690183334216587398645213023148750443295007000911541566340284156527080509545145423451091853688188705902833261507474200445477515893168405730493924172626222872760780966427
e = 65537
ct = 18440162368010249375653348677429595229051180035668845001125855048750591059785630865891877031796050869136099359028540172514890273415892550857190509410541828375948243175466417949548148007390803680005616875833010137407850955608659023797782656930905693262770473679394796595557898347900786445803645539553815614140428316398058138450937721961593146082399553119578102712100359284788650328835784603011091312735813903241087475279011862693938914825685547337081335030237385061397899718079346063519325222861490101383929790275635381333028091769118083102339908694751574572782030287570280071809896532329742115422479473386147281509394

(p, q) = findPandQ(n)
phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
plain = pow(ct,d,n)
print(long_to_bytes(plain))
```

Flag: `OSCTF{m4y_7h3_pR1m3_10v3_34cH_07h3r?}`

```
